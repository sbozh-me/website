# 0.6.2 - Blog API Layer

## Goal

Create DirectusRepository in packages/blog that implements the existing BlogRepository interface.

## Deliverables

- [ ] DirectusRepository implements BlogRepository interface
- [ ] Directus SDK configured with REST transport
- [ ] Constructor accepts url, token, includeDrafts options
- [ ] All CRUD operations working against Directus API
- [ ] Proper TypeScript types for Directus responses
- [ ] Unit tests with mocked Directus responses

## Files to Create/Modify

```
packages/blog/
  src/
    data/
      directus-repository.ts  # New: Directus implementation
      index.ts                # Export DirectusRepository
    types/
      post.ts                 # Add status field
  package.json                # Add @directus/sdk
```

## Dependencies

```json
{
  "dependencies": {
    "@directus/sdk": "^18.0.0"
  }
}
```

## DirectusRepository Implementation

```typescript
// packages/blog/src/data/directus-repository.ts
import { createDirectus, rest, readItems, staticToken } from '@directus/sdk';
import type {
  BlogRepository,
  Post,
  PostListItem,
  Persona,
  Tag,
  PostFilters,
} from '../types';

// Directus collection types
interface DirectusPost {
  id: string;
  status: 'published' | 'draft';
  title: string;
  slug: string;
  excerpt: string;
  content: string;
  date_published: string;
  reading_time: number;
  persona: DirectusPersona;
  tags: { tags_id: DirectusTag }[];
  image: DirectusFile | null;
}

interface DirectusPersona {
  id: string;
  name: string;
  slug: string;
  color: string;
  description: string | null;
}

interface DirectusTag {
  id: string;
  name: string;
  slug: string;
}

interface DirectusFile {
  id: string;
  filename_download: string;
  width: number;
  height: number;
}

export interface DirectusConfig {
  url: string;
  token?: string;
  includeDrafts?: boolean;
}

export class DirectusRepository implements BlogRepository {
  private client;
  private baseUrl: string;
  private includeDrafts: boolean;

  constructor(config: DirectusConfig) {
    this.baseUrl = config.url;
    this.includeDrafts = config.includeDrafts ?? false;

    let client = createDirectus(config.url).with(rest());
    if (config.token) {
      client = client.with(staticToken(config.token));
    }
    this.client = client;
  }

  async getPosts(filters?: PostFilters): Promise<PostListItem[]> {
    const directusFilter = this.buildFilter(filters);

    const posts = await this.client.request(
      readItems('posts', {
        filter: directusFilter,
        fields: [
          'id', 'status', 'title', 'slug', 'excerpt',
          'date_published', 'reading_time',
          'persona.id', 'persona.name', 'persona.slug', 'persona.color',
          'tags.tags_id.id', 'tags.tags_id.name', 'tags.tags_id.slug',
          'image.id', 'image.filename_download', 'image.width', 'image.height',
        ],
        sort: ['-date_published'],
      })
    );

    return posts.map(this.mapToPostListItem.bind(this));
  }

  async getPost(slug: string): Promise<Post | null> {
    const filter: any = { slug: { _eq: slug } };
    if (!this.includeDrafts) {
      filter.status = { _eq: 'published' };
    }

    const posts = await this.client.request(
      readItems('posts', {
        filter,
        fields: ['*', 'persona.*', 'tags.tags_id.*', 'image.*'],
        limit: 1,
      })
    );

    if (posts.length === 0) return null;
    return this.mapToPost(posts[0]);
  }

  async getPersonas(): Promise<Persona[]> {
    const personas = await this.client.request(
      readItems('personas', { fields: ['*'] })
    );
    return personas.map(this.mapToPersona);
  }

  async getTags(): Promise<Tag[]> {
    const tags = await this.client.request(
      readItems('tags', { fields: ['*'] })
    );
    return tags.map(this.mapToTag);
  }

  private buildFilter(filters?: PostFilters): Record<string, any> {
    const directusFilter: any = {};

    if (!this.includeDrafts) {
      directusFilter.status = { _eq: 'published' };
    }

    if (filters?.persona) {
      directusFilter.persona = { slug: { _eq: filters.persona } };
    }

    if (filters?.tag) {
      directusFilter.tags = { tags_id: { slug: { _eq: filters.tag } } };
    }

    if (filters?.year) {
      directusFilter.date_published = {
        _gte: `${filters.year}-01-01`,
        _lt: `${filters.year + 1}-01-01`,
      };
    }

    return directusFilter;
  }

  private mapToPost(post: DirectusPost): Post {
    return {
      id: post.id,
      title: post.title,
      slug: post.slug,
      excerpt: post.excerpt,
      content: post.content,
      date: post.date_published,
      readingTime: post.reading_time,
      persona: this.mapToPersona(post.persona),
      tags: post.tags.map((t) => this.mapToTag(t.tags_id)),
      image: post.image ? this.mapToImage(post.image) : undefined,
    };
  }

  private mapToPostListItem(post: DirectusPost): PostListItem {
    const { content: _, ...rest } = this.mapToPost(post);
    return rest;
  }

  private mapToPersona(persona: DirectusPersona): Persona {
    return {
      id: persona.id,
      name: persona.name,
      slug: persona.slug,
      color: persona.color,
      description: persona.description ?? undefined,
    };
  }

  private mapToTag(tag: DirectusTag): Tag {
    return {
      id: tag.id,
      name: tag.name,
      slug: tag.slug,
    };
  }

  private mapToImage(file: DirectusFile) {
    return {
      src: `${this.baseUrl}/assets/${file.id}`,
      alt: file.filename_download,
      width: file.width,
      height: file.height,
    };
  }
}
```

## Type Updates

Add `status` to Post type:

```typescript
// packages/blog/src/types/post.ts
export interface Post {
  // ... existing fields
  status?: 'published' | 'draft';
}
```

## Export Updates

```typescript
// packages/blog/src/data/index.ts
export { DirectusRepository } from './directus-repository';
export type { DirectusConfig } from './directus-repository';
```

## Acceptance Criteria

- [ ] DirectusRepository class created and exported
- [ ] Implements all 4 BlogRepository methods
- [ ] getPosts() excludes drafts by default
- [ ] getPosts() supports persona, tag, year filters
- [ ] getPost() returns null for non-existent slugs
- [ ] Images mapped to full asset URLs
- [ ] M2M tags properly flattened
- [ ] Unit tests with mocked SDK responses
- [ ] TypeScript compiles without errors
