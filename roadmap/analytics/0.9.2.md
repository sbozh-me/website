# 0.9.2 - Advanced Tracking & Privacy

## Goal
Implement comprehensive event tracking for user interactions, performance metrics, and conversion goals while preparing privacy compliance infrastructure for cookie consent and data protection.

## Deliverables
- [ ] Implement advanced event tracking patterns
- [ ] Add performance monitoring (Core Web Vitals)
- [ ] Create conversion goal tracking
- [ ] Build user journey analytics
- [ ] Prepare cookie consent infrastructure
- [ ] Configure data retention policies
- [ ] Add tracking opt-out mechanisms

## Implementation

### Advanced Event Tracking System

```typescript
// packages/web/src/lib/analytics/events.ts

export enum EventCategory {
  Navigation = 'navigation',
  Content = 'content',
  Social = 'social',
  Form = 'form',
  Commerce = 'commerce',
  Media = 'media',
  Search = 'search',
  User = 'user',
  Performance = 'performance',
}

export enum EventAction {
  Click = 'click',
  View = 'view',
  Submit = 'submit',
  Share = 'share',
  Download = 'download',
  Play = 'play',
  Pause = 'pause',
  Complete = 'complete',
  Error = 'error',
  Success = 'success',
}

interface EventData {
  category: EventCategory;
  action: EventAction;
  label?: string;
  value?: number;
  metadata?: Record<string, any>;
}

export class AnalyticsEvents {
  private queue: EventData[] = [];
  private isOnline = true;

  constructor() {
    if (typeof window !== 'undefined') {
      this.isOnline = navigator.onLine;
      window.addEventListener('online', () => this.handleOnline());
      window.addEventListener('offline', () => this.handleOffline());
    }
  }

  track(event: EventData) {
    // Check consent
    if (!this.hasConsent()) {
      console.log('[Analytics] Tracking blocked - no consent');
      return;
    }

    // Add timestamp
    const enrichedEvent = {
      ...event,
      timestamp: Date.now(),
      sessionId: this.getSessionId(),
    };

    if (this.isOnline) {
      this.send(enrichedEvent);
    } else {
      this.queue.push(enrichedEvent);
    }
  }

  private send(event: EventData & { timestamp: number; sessionId: string }) {
    if (window.umami) {
      window.umami.track(event.category + '_' + event.action, {
        label: event.label,
        value: event.value,
        ...event.metadata,
      });
    }
  }

  private handleOnline() {
    this.isOnline = true;
    // Flush queued events
    while (this.queue.length > 0) {
      const event = this.queue.shift();
      if (event) this.send(event as any);
    }
  }

  private handleOffline() {
    this.isOnline = false;
  }

  private hasConsent(): boolean {
    // Check localStorage for consent
    const consent = localStorage.getItem('analytics_consent');
    return consent === 'granted';
  }

  private getSessionId(): string {
    let sessionId = sessionStorage.getItem('analytics_session_id');
    if (!sessionId) {
      sessionId = crypto.randomUUID();
      sessionStorage.setItem('analytics_session_id', sessionId);
    }
    return sessionId;
  }
}

export const analyticsEvents = new AnalyticsEvents();
```

### Core Web Vitals Tracking

```typescript
// packages/web/src/lib/analytics/performance.ts
import { onCLS, onFCP, onFID, onINP, onLCP, onTTFB } from 'web-vitals';
import { analyticsEvents, EventCategory, EventAction } from './events';

interface MetricData {
  name: string;
  value: number;
  rating: 'good' | 'needs-improvement' | 'poor';
  delta: number;
  id: string;
}

export function initPerformanceTracking() {
  if (typeof window === 'undefined') return;

  const sendMetric = (metric: MetricData) => {
    // Send to analytics
    analyticsEvents.track({
      category: EventCategory.Performance,
      action: EventAction.View,
      label: metric.name,
      value: Math.round(metric.value),
      metadata: {
        rating: metric.rating,
        delta: metric.delta,
        id: metric.id,
        url: window.location.pathname,
      },
    });

    // Also send to GlitchTip as custom metric
    if (window.Sentry) {
      window.Sentry.addBreadcrumb({
        category: 'web-vital',
        message: `${metric.name}: ${metric.value}`,
        level: metric.rating === 'poor' ? 'warning' : 'info',
        data: metric,
      });
    }
  };

  // Core Web Vitals
  onCLS(sendMetric); // Cumulative Layout Shift
  onFCP(sendMetric); // First Contentful Paint
  onFID(sendMetric); // First Input Delay (deprecated, use INP)
  onINP(sendMetric); // Interaction to Next Paint
  onLCP(sendMetric); // Largest Contentful Paint
  onTTFB(sendMetric); // Time to First Byte

  // Custom performance metrics
  observeResourceTiming();
  observeNavigationTiming();
  observeLongTasks();
}

function observeResourceTiming() {
  if (!('PerformanceObserver' in window)) return;

  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.entryType === 'resource') {
        const resource = entry as PerformanceResourceTiming;

        // Track slow resources
        if (resource.duration > 1000) {
          analyticsEvents.track({
            category: EventCategory.Performance,
            action: EventAction.View,
            label: 'slow_resource',
            value: Math.round(resource.duration),
            metadata: {
              name: resource.name,
              type: resource.initiatorType,
              size: resource.transferSize,
            },
          });
        }
      }
    }
  });

  observer.observe({ entryTypes: ['resource'] });
}

function observeNavigationTiming() {
  if (!('PerformanceObserver' in window)) return;

  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.entryType === 'navigation') {
        const nav = entry as PerformanceNavigationTiming;

        analyticsEvents.track({
          category: EventCategory.Performance,
          action: EventAction.View,
          label: 'navigation',
          value: Math.round(nav.loadEventEnd - nav.fetchStart),
          metadata: {
            domContentLoaded: Math.round(nav.domContentLoadedEventEnd - nav.fetchStart),
            domInteractive: Math.round(nav.domInteractive - nav.fetchStart),
            type: nav.type, // navigate, reload, back_forward
          },
        });
      }
    }
  });

  observer.observe({ entryTypes: ['navigation'] });
}

function observeLongTasks() {
  if (!('PerformanceLongTaskTiming' in window)) return;

  const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      // Track tasks longer than 50ms
      analyticsEvents.track({
        category: EventCategory.Performance,
        action: EventAction.View,
        label: 'long_task',
        value: Math.round(entry.duration),
        metadata: {
          startTime: entry.startTime,
          name: entry.name,
        },
      });
    }
  });

  observer.observe({ entryTypes: ['longtask'] });
}
```

### User Journey Tracking

```typescript
// packages/web/src/lib/analytics/journey.ts
import { analyticsEvents, EventCategory, EventAction } from './events';

interface JourneyStep {
  step: string;
  timestamp: number;
  metadata?: Record<string, any>;
}

class UserJourney {
  private journey: JourneyStep[] = [];
  private journeyKey = 'user_journey';
  private maxSteps = 50;

  constructor() {
    this.loadJourney();
  }

  track(step: string, metadata?: Record<string, any>) {
    const journeyStep: JourneyStep = {
      step,
      timestamp: Date.now(),
      metadata,
    };

    this.journey.push(journeyStep);

    // Keep journey size manageable
    if (this.journey.length > this.maxSteps) {
      this.journey.shift();
    }

    this.saveJourney();

    // Track the step
    analyticsEvents.track({
      category: EventCategory.User,
      action: EventAction.View,
      label: step,
      metadata: {
        ...metadata,
        journeyLength: this.journey.length,
      },
    });
  }

  getJourney(): JourneyStep[] {
    return [...this.journey];
  }

  clearJourney() {
    this.journey = [];
    sessionStorage.removeItem(this.journeyKey);
  }

  private loadJourney() {
    try {
      const saved = sessionStorage.getItem(this.journeyKey);
      if (saved) {
        this.journey = JSON.parse(saved);
      }
    } catch (error) {
      console.error('Failed to load journey:', error);
    }
  }

  private saveJourney() {
    try {
      sessionStorage.setItem(this.journeyKey, JSON.stringify(this.journey));
    } catch (error) {
      console.error('Failed to save journey:', error);
    }
  }
}

export const userJourney = new UserJourney();

// Journey hooks
export function useJourneyTracking() {
  const trackStep = (step: string, metadata?: Record<string, any>) => {
    userJourney.track(step, metadata);
  };

  const trackConversion = (goal: string, value?: number) => {
    analyticsEvents.track({
      category: EventCategory.Commerce,
      action: EventAction.Success,
      label: goal,
      value,
      metadata: {
        journey: userJourney.getJourney().map(s => s.step).slice(-10), // Last 10 steps
      },
    });
  };

  return { trackStep, trackConversion };
}
```

### Cookie Consent Manager (Preparation)

```typescript
// packages/web/src/lib/privacy/consent.ts

export enum ConsentType {
  Analytics = 'analytics',
  Marketing = 'marketing',
  Functional = 'functional',
  Necessary = 'necessary',
}

interface ConsentState {
  [ConsentType.Analytics]: boolean;
  [ConsentType.Marketing]: boolean;
  [ConsentType.Functional]: boolean;
  [ConsentType.Necessary]: boolean;
  timestamp: number;
  version: string;
}

class ConsentManager {
  private storageKey = 'cookie_consent';
  private consentVersion = '1.0.0';
  private state: ConsentState;

  constructor() {
    this.state = this.loadConsent() || this.getDefaultConsent();
  }

  getDefaultConsent(): ConsentState {
    return {
      [ConsentType.Analytics]: false,
      [ConsentType.Marketing]: false,
      [ConsentType.Functional]: true,
      [ConsentType.Necessary]: true, // Always true
      timestamp: Date.now(),
      version: this.consentVersion,
    };
  }

  loadConsent(): ConsentState | null {
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        const consent = JSON.parse(stored) as ConsentState;
        // Check version compatibility
        if (consent.version !== this.consentVersion) {
          return null; // Force re-consent on version change
        }
        return consent;
      }
    } catch (error) {
      console.error('Failed to load consent:', error);
    }
    return null;
  }

  saveConsent(consent: Partial<ConsentState>) {
    this.state = {
      ...this.state,
      ...consent,
      timestamp: Date.now(),
      version: this.consentVersion,
    };

    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.state));
      this.applyConsent();
      this.notifyConsentChange();
    } catch (error) {
      console.error('Failed to save consent:', error);
    }
  }

  hasConsent(type: ConsentType): boolean {
    return this.state[type];
  }

  grantAll() {
    this.saveConsent({
      [ConsentType.Analytics]: true,
      [ConsentType.Marketing]: true,
      [ConsentType.Functional]: true,
    });
  }

  denyAll() {
    this.saveConsent({
      [ConsentType.Analytics]: false,
      [ConsentType.Marketing]: false,
      [ConsentType.Functional]: false,
    });
  }

  private applyConsent() {
    // Apply analytics consent
    if (this.state[ConsentType.Analytics]) {
      this.enableAnalytics();
    } else {
      this.disableAnalytics();
    }

    // Apply marketing consent
    if (this.state[ConsentType.Marketing]) {
      this.enableMarketing();
    } else {
      this.disableMarketing();
    }
  }

  private enableAnalytics() {
    // Enable Umami
    localStorage.setItem('analytics_consent', 'granted');

    // Enable GlitchTip
    if (window.Sentry) {
      window.Sentry.getCurrentHub().getClient()?.getOptions().enabled = true;
    }
  }

  private disableAnalytics() {
    // Disable Umami
    localStorage.setItem('analytics_consent', 'denied');

    // Disable GlitchTip
    if (window.Sentry) {
      window.Sentry.getCurrentHub().getClient()?.getOptions().enabled = false;
    }

    // Clear any stored analytics data
    this.clearAnalyticsData();
  }

  private enableMarketing() {
    // Placeholder for future marketing tools
  }

  private disableMarketing() {
    // Placeholder for future marketing tools
  }

  private clearAnalyticsData() {
    // Clear session storage
    sessionStorage.removeItem('analytics_session_id');
    sessionStorage.removeItem('user_journey');

    // Clear Umami data if possible
    if (window.umami) {
      // Umami doesn't store client-side data
    }
  }

  private notifyConsentChange() {
    // Dispatch custom event for components to react
    window.dispatchEvent(new CustomEvent('consentchange', {
      detail: this.state,
    }));
  }
}

export const consentManager = new ConsentManager();
```

### Privacy Controls Component

```tsx
// packages/web/src/components/PrivacyControls.tsx
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@sbozh/react-ui/components/ui/button';
import { Switch } from '@sbozh/react-ui/components/ui/switch';
import { consentManager, ConsentType } from '@/lib/privacy/consent';

export function PrivacyControls() {
  const [consent, setConsent] = useState({
    analytics: false,
    marketing: false,
    functional: true,
  });

  useEffect(() => {
    // Load current consent state
    setConsent({
      analytics: consentManager.hasConsent(ConsentType.Analytics),
      marketing: consentManager.hasConsent(ConsentType.Marketing),
      functional: consentManager.hasConsent(ConsentType.Functional),
    });

    // Listen for consent changes
    const handleConsentChange = (event: CustomEvent) => {
      const state = event.detail;
      setConsent({
        analytics: state[ConsentType.Analytics],
        marketing: state[ConsentType.Marketing],
        functional: state[ConsentType.Functional],
      });
    };

    window.addEventListener('consentchange', handleConsentChange as any);
    return () => {
      window.removeEventListener('consentchange', handleConsentChange as any);
    };
  }, []);

  const handleToggle = (type: keyof typeof consent) => {
    const newValue = !consent[type];
    setConsent(prev => ({ ...prev, [type]: newValue }));

    // Map to ConsentType enum
    const consentType = type as keyof typeof ConsentType;
    consentManager.saveConsent({
      [ConsentType[consentType.charAt(0).toUpperCase() + consentType.slice(1)]]: newValue,
    });
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-medium mb-4">Privacy Settings</h3>
        <p className="text-sm text-muted-foreground mb-6">
          Control how your data is collected and used. These settings apply immediately.
        </p>
      </div>

      <div className="space-y-4">
        <div className="flex items-center justify-between p-4 border rounded-lg">
          <div className="flex-1">
            <h4 className="font-medium">Necessary Cookies</h4>
            <p className="text-sm text-muted-foreground">
              Essential for the website to function. Cannot be disabled.
            </p>
          </div>
          <Switch checked={true} disabled />
        </div>

        <div className="flex items-center justify-between p-4 border rounded-lg">
          <div className="flex-1">
            <h4 className="font-medium">Analytics Cookies</h4>
            <p className="text-sm text-muted-foreground">
              Help us understand how visitors use our website.
            </p>
          </div>
          <Switch
            checked={consent.analytics}
            onCheckedChange={() => handleToggle('analytics')}
          />
        </div>

        <div className="flex items-center justify-between p-4 border rounded-lg">
          <div className="flex-1">
            <h4 className="font-medium">Functional Cookies</h4>
            <p className="text-sm text-muted-foreground">
              Enable enhanced functionality and personalization.
            </p>
          </div>
          <Switch
            checked={consent.functional}
            onCheckedChange={() => handleToggle('functional')}
          />
        </div>

        <div className="flex items-center justify-between p-4 border rounded-lg">
          <div className="flex-1">
            <h4 className="font-medium">Marketing Cookies</h4>
            <p className="text-sm text-muted-foreground">
              Used to track visitors across websites for advertising.
            </p>
          </div>
          <Switch
            checked={consent.marketing}
            onCheckedChange={() => handleToggle('marketing')}
          />
        </div>
      </div>

      <div className="flex gap-4">
        <Button
          variant="outline"
          onClick={() => consentManager.denyAll()}
        >
          Deny All
        </Button>
        <Button
          onClick={() => consentManager.grantAll()}
        >
          Accept All
        </Button>
      </div>

      <div className="text-xs text-muted-foreground">
        <p>Your preferences are saved locally and respected across all pages.</p>
        <p>We use Umami Analytics (privacy-friendly, no cookies) and GlitchTip for error tracking.</p>
      </div>
    </div>
  );
}
```

### Data Retention Configuration

```typescript
// packages/web/src/lib/analytics/retention.ts

interface RetentionPolicy {
  analytics: number; // days
  errors: number; // days
  performance: number; // days
  userJourney: number; // days
}

export const dataRetentionPolicy: RetentionPolicy = {
  analytics: 90, // 3 months
  errors: 30, // 1 month
  performance: 7, // 1 week
  userJourney: 1, // Session only
};

// This configuration should match your Umami and GlitchTip settings
export function configureDataRetention() {
  // Umami: Configure in dashboard settings
  // GlitchTip: Configure in project settings

  // Client-side cleanup
  scheduleDataCleanup();
}

function scheduleDataCleanup() {
  // Run cleanup daily
  setInterval(() => {
    cleanupOldData();
  }, 24 * 60 * 60 * 1000);

  // Run on page load
  cleanupOldData();
}

function cleanupOldData() {
  const now = Date.now();

  // Clean localStorage
  const keysToCheck = [
    'analytics_last_event',
    'performance_metrics',
    'user_preferences',
  ];

  keysToCheck.forEach(key => {
    const data = localStorage.getItem(key);
    if (data) {
      try {
        const parsed = JSON.parse(data);
        if (parsed.timestamp && (now - parsed.timestamp) > dataRetentionPolicy.analytics * 24 * 60 * 60 * 1000) {
          localStorage.removeItem(key);
        }
      } catch {
        // Invalid data, remove it
        localStorage.removeItem(key);
      }
    }
  });
}
```

## Files to Create

| File | Purpose |
|------|---------|
| `packages/web/src/lib/analytics/events.ts` | Advanced event tracking system |
| `packages/web/src/lib/analytics/performance.ts` | Web Vitals tracking |
| `packages/web/src/lib/analytics/journey.ts` | User journey tracking |
| `packages/web/src/lib/privacy/consent.ts` | Consent management |
| `packages/web/src/lib/analytics/retention.ts` | Data retention policies |
| `packages/web/src/components/PrivacyControls.tsx` | Privacy settings UI |

## Files to Modify

| File | Changes |
|------|---------|
| `packages/web/src/app/layout.tsx` | Initialize performance tracking |
| `package.json` | Add web-vitals dependency |
| `apps/web/.env.example` | Add privacy configuration |

## Acceptance Criteria

- [ ] Advanced events tracked properly
- [ ] Core Web Vitals collected
- [ ] User journey tracked across session
- [ ] Consent manager functional
- [ ] Privacy controls accessible
- [ ] Data retention configured
- [ ] Analytics respect user consent
- [ ] Performance metrics in dashboard
- [ ] No PII leaked in events
- [ ] Offline event queuing works

## Testing

```typescript
// packages/web/src/lib/analytics/__tests__/consent.test.ts
import { consentManager, ConsentType } from '../consent';

describe('ConsentManager', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('should default to minimal consent', () => {
    expect(consentManager.hasConsent(ConsentType.Analytics)).toBe(false);
    expect(consentManager.hasConsent(ConsentType.Marketing)).toBe(false);
    expect(consentManager.hasConsent(ConsentType.Necessary)).toBe(true);
  });

  it('should persist consent choices', () => {
    consentManager.saveConsent({
      [ConsentType.Analytics]: true,
    });

    const stored = localStorage.getItem('cookie_consent');
    expect(stored).toBeTruthy();

    const parsed = JSON.parse(stored!);
    expect(parsed.analytics).toBe(true);
  });

  it('should apply consent immediately', () => {
    const analyticsSpy = jest.spyOn(localStorage, 'setItem');

    consentManager.saveConsent({
      [ConsentType.Analytics]: true,
    });

    expect(analyticsSpy).toHaveBeenCalledWith('analytics_consent', 'granted');
  });
});
```

## Notes

- Privacy-first approach with opt-in analytics
- No PII collected without explicit consent
- Consent UI will be shown as banner in future version
- Consider GDPR/CCPA compliance requirements
- Regular privacy audits recommended
- Document all tracking in privacy policy