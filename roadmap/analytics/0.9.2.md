# 0.9.2 - GlitchTip Error Tracking Integration

## Goal
Integrate GlitchTip error tracking using Sentry SDK for comprehensive error monitoring in both frontend and backend code, with proper error boundaries and source map support.

## Deliverables
- [ ] Install and configure Sentry SDK (GlitchTip compatible)
- [ ] Set up React error boundaries
- [ ] Configure backend error handling
- [ ] Implement source map upload
- [ ] Add user context tracking
- [ ] Create error monitoring utilities
- [ ] Test error capture across environments

## Implementation

### Sentry SDK Installation

```bash
# Install Sentry SDK (compatible with GlitchTip)
pnpm add @sentry/nextjs @sentry/react @sentry/node
```

### Sentry Configuration

```javascript
// sentry.client.config.ts
import * as Sentry from '@sentry/nextjs';

const SENTRY_DSN = process.env.NEXT_PUBLIC_GLITCHTIP_DSN;
const environment = process.env.NEXT_PUBLIC_APP_ENV || 'development';

Sentry.init({
  dsn: SENTRY_DSN,
  environment,
  tracesSampleRate: environment === 'production' ? 0.1 : 1.0,
  debug: process.env.NODE_ENV === 'development',

  // GlitchTip specific settings
  integrations: [
    new Sentry.BrowserTracing({
      // Disable automatic route change tracking (we'll do it manually)
      routingInstrumentation: Sentry.reactRouterV6Instrumentation(
        React.useEffect,
        useLocation,
        useNavigationType,
        createRoutesFromChildren,
        matchRoutes
      ),
    }),
    new Sentry.Replay({
      maskAllText: true,
      blockAllMedia: true,
      // Only capture replays on errors in production
      sessionSampleRate: environment === 'production' ? 0 : 0.1,
      errorSampleRate: 1.0,
    }),
  ],

  // Filtering
  ignoreErrors: [
    // Browser extensions
    'top.GLOBALS',
    // Random network errors
    'Network request failed',
    'NetworkError',
    'Failed to fetch',
    // User cancellations
    'AbortError',
    'Non-Error promise rejection captured',
    // Common false positives
    'ResizeObserver loop limit exceeded',
    'ResizeObserver loop completed with undelivered notifications',
  ],

  beforeSend(event, hint) {
    // Filter out certain errors in development
    if (environment === 'development') {
      if (event.exception?.values?.[0]?.type === 'ChunkLoadError') {
        return null;
      }
    }

    // Add user context if available
    const user = getCurrentUser(); // Your user fetching logic
    if (user) {
      event.user = {
        id: user.id,
        email: user.email,
        username: user.username,
      };
    }

    // Scrub sensitive data
    if (event.request?.cookies) {
      delete event.request.cookies;
    }

    return event;
  },

  // GlitchTip endpoint (self-hosted)
  tunnel: process.env.NEXT_PUBLIC_GLITCHTIP_TUNNEL,
});
```

### Server-side Configuration

```javascript
// sentry.server.config.ts
import * as Sentry from '@sentry/nextjs';

const SENTRY_DSN = process.env.GLITCHTIP_DSN;
const environment = process.env.APP_ENV || 'development';

Sentry.init({
  dsn: SENTRY_DSN,
  environment,
  tracesSampleRate: environment === 'production' ? 0.1 : 1.0,

  integrations: [
    // Automatically instrument Node.js libraries and frameworks
    ...Sentry.autoDiscoverNodePerformanceMonitoringIntegrations(),
  ],

  // Capture unhandled promise rejections
  onUnhandledRejection: 'warn',

  beforeSend(event) {
    // Don't send events in test environment
    if (process.env.NODE_ENV === 'test') {
      return null;
    }

    // Scrub sensitive server data
    if (event.request?.headers) {
      delete event.request.headers.cookie;
      delete event.request.headers.authorization;
    }

    return event;
  },
});
```

### Error Boundary Component

```tsx
// packages/web/src/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import * as Sentry from '@sentry/nextjs';
import { Button } from '@sbozh/react-ui/components/ui/button';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  showDialog?: boolean;
  onReset?: () => void;
}

interface State {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
  eventId?: string;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    const eventId = Sentry.captureException(error, {
      contexts: {
        react: {
          componentStack: errorInfo.componentStack,
        },
      },
      level: 'error',
    });

    this.setState({
      error,
      errorInfo,
      eventId,
    });

    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error boundary caught:', error, errorInfo);
    }
  }

  handleReset = () => {
    this.setState({ hasError: false, error: undefined, errorInfo: undefined });
    this.props.onReset?.();
  };

  handleReport = () => {
    if (this.props.showDialog && this.state.eventId) {
      Sentry.showReportDialog({ eventId: this.state.eventId });
    }
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="flex min-h-[400px] flex-col items-center justify-center p-8">
          <div className="max-w-md text-center">
            <h2 className="mb-4 text-2xl font-bold">Something went wrong</h2>
            <p className="mb-6 text-muted-foreground">
              An unexpected error occurred. The error has been reported and we'll look into it.
            </p>

            {process.env.NODE_ENV === 'development' && this.state.error && (
              <details className="mb-6 text-left">
                <summary className="cursor-pointer text-sm font-medium">Error details</summary>
                <pre className="mt-2 overflow-auto rounded bg-gray-100 p-2 text-xs">
                  {this.state.error.toString()}
                  {this.state.errorInfo?.componentStack}
                </pre>
              </details>
            )}

            <div className="flex gap-4 justify-center">
              <Button onClick={this.handleReset}>
                Try again
              </Button>

              {this.props.showDialog && (
                <Button variant="outline" onClick={this.handleReport}>
                  Report issue
                </Button>
              )}
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Error Tracking Utilities

```typescript
// packages/web/src/lib/error-tracking.ts
import * as Sentry from '@sentry/nextjs';

export enum ErrorLevel {
  Debug = 'debug',
  Info = 'info',
  Warning = 'warning',
  Error = 'error',
  Fatal = 'fatal',
}

interface ErrorContext {
  user?: {
    id: string;
    email?: string;
  };
  tags?: Record<string, string>;
  extra?: Record<string, any>;
}

class ErrorTracker {
  /**
   * Capture an exception with context
   */
  captureException(error: Error | unknown, context?: ErrorContext): string | undefined {
    if (context?.user) {
      Sentry.setUser(context.user);
    }

    if (context?.tags) {
      Sentry.setTags(context.tags);
    }

    const eventId = Sentry.captureException(error, {
      extra: context?.extra,
    });

    // Clear user context after capture to avoid leaking between errors
    if (context?.user) {
      Sentry.setUser(null);
    }

    return eventId;
  }

  /**
   * Log a message with severity level
   */
  captureMessage(message: string, level: ErrorLevel = ErrorLevel.Info, context?: ErrorContext): string | undefined {
    if (context?.tags) {
      Sentry.setTags(context.tags);
    }

    return Sentry.captureMessage(message, level as Sentry.SeverityLevel, {
      extra: context?.extra,
    });
  }

  /**
   * Add breadcrumb for better error context
   */
  addBreadcrumb(message: string, category: string, data?: Record<string, any>) {
    Sentry.addBreadcrumb({
      message,
      category,
      level: 'info',
      data,
      timestamp: Date.now() / 1000,
    });
  }

  /**
   * Track custom performance metrics
   */
  startTransaction(name: string, op: string) {
    return Sentry.startTransaction({ name, op });
  }

  /**
   * Set user context globally
   */
  setUser(user: { id: string; email?: string; username?: string } | null) {
    Sentry.setUser(user);
  }

  /**
   * Set custom tags
   */
  setTag(key: string, value: string) {
    Sentry.setTag(key, value);
  }

  /**
   * Track API errors with additional context
   */
  captureAPIError(
    endpoint: string,
    method: string,
    status: number,
    error: any,
    requestData?: any
  ) {
    this.captureException(error, {
      tags: {
        type: 'api_error',
        endpoint,
        method,
        status: String(status),
      },
      extra: {
        requestData: this.sanitizeData(requestData),
      },
    });
  }

  /**
   * Sanitize sensitive data before sending
   */
  private sanitizeData(data: any): any {
    if (!data) return data;

    const sensitive = ['password', 'token', 'secret', 'api_key', 'authorization'];
    const sanitized = { ...data };

    for (const key in sanitized) {
      if (sensitive.some(s => key.toLowerCase().includes(s))) {
        sanitized[key] = '[REDACTED]';
      }
    }

    return sanitized;
  }
}

export const errorTracker = new ErrorTracker();
```

### API Route Error Handling

```typescript
// apps/web/src/app/api/middleware/error-handler.ts
import { NextRequest, NextResponse } from 'next/server';
import { errorTracker } from '@/lib/error-tracking';

export function withErrorHandler(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest) => {
    try {
      return await handler(req);
    } catch (error) {
      const { pathname, searchParams } = new URL(req.url);

      errorTracker.captureAPIError(
        pathname,
        req.method,
        500,
        error,
        {
          query: Object.fromEntries(searchParams),
          headers: Object.fromEntries(req.headers),
        }
      );

      return NextResponse.json(
        {
          error: 'Internal Server Error',
          message: process.env.NODE_ENV === 'development'
            ? (error as Error).message
            : 'An error occurred processing your request',
        },
        { status: 500 }
      );
    }
  };
}

// Usage in API route
export const GET = withErrorHandler(async (req) => {
  // Your API logic
  return NextResponse.json({ data: 'success' });
});
```

### Next.js Configuration

```javascript
// next.config.js
const { withSentryConfig } = require('@sentry/nextjs');

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Your existing Next.js config
  reactStrictMode: true,

  // Sentry options
  sentry: {
    hideSourceMaps: true,
    widenClientFileUpload: true,
  },
};

const sentryWebpackPluginOptions = {
  // GlitchTip configuration
  org: process.env.SENTRY_ORG,
  project: process.env.SENTRY_PROJECT,
  authToken: process.env.SENTRY_AUTH_TOKEN,
  silent: true,

  // Upload source maps to GlitchTip
  include: '.next',
  ignore: ['node_modules'],
  urlPrefix: '~/_next',

  // Don't upload in development
  dryRun: process.env.NODE_ENV === 'development',
};

module.exports = withSentryConfig(nextConfig, sentryWebpackPluginOptions);
```

### Environment Variables

```bash
# apps/web/.env.local

# GlitchTip Configuration (Sentry-compatible DSN)
NEXT_PUBLIC_GLITCHTIP_DSN=http://your-key@localhost:3002/1
GLITCHTIP_DSN=http://your-key@localhost:3002/1

# Optional: For bypassing ad blockers
NEXT_PUBLIC_GLITCHTIP_TUNNEL=/api/tunnel

# Source map upload (for production)
SENTRY_ORG=sbozh
SENTRY_PROJECT=website
SENTRY_AUTH_TOKEN=your-glitchtip-auth-token

# Environment
NEXT_PUBLIC_APP_ENV=development
APP_ENV=development
```

### Testing Error Capture

```tsx
// packages/web/src/components/TestError.tsx
'use client';

import { useState } from 'react';
import { Button } from '@sbozh/react-ui/components/ui/button';
import { errorTracker, ErrorLevel } from '@/lib/error-tracking';

export function TestError() {
  const [isLoading, setIsLoading] = useState(false);

  const triggerClientError = () => {
    throw new Error('Test client error');
  };

  const triggerAsyncError = async () => {
    setIsLoading(true);
    try {
      await new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Test async error')), 1000);
      });
    } catch (error) {
      errorTracker.captureException(error, {
        tags: { type: 'test', location: 'client' },
        extra: { timestamp: new Date().toISOString() },
      });
    } finally {
      setIsLoading(false);
    }
  };

  const triggerAPIError = async () => {
    const response = await fetch('/api/test-error');
    if (!response.ok) {
      errorTracker.captureAPIError(
        '/api/test-error',
        'GET',
        response.status,
        new Error(`API Error: ${response.statusText}`)
      );
    }
  };

  const logMessage = () => {
    errorTracker.captureMessage('Test message from client', ErrorLevel.Info, {
      tags: { type: 'test' },
      extra: { userAction: 'button_click' },
    });
  };

  if (process.env.NODE_ENV === 'production') {
    return null;
  }

  return (
    <div className="flex gap-4 p-4 border rounded bg-yellow-50">
      <Button onClick={triggerClientError} variant="destructive">
        Trigger Client Error
      </Button>
      <Button onClick={triggerAsyncError} disabled={isLoading}>
        {isLoading ? 'Loading...' : 'Trigger Async Error'}
      </Button>
      <Button onClick={triggerAPIError}>
        Trigger API Error
      </Button>
      <Button onClick={logMessage}>
        Log Test Message
      </Button>
    </div>
  );
}
```

## Files to Create

| File | Purpose |
|------|---------|
| `sentry.client.config.ts` | Client-side Sentry configuration |
| `sentry.server.config.ts` | Server-side Sentry configuration |
| `sentry.edge.config.ts` | Edge runtime configuration |
| `packages/web/src/components/ErrorBoundary.tsx` | React error boundary |
| `packages/web/src/lib/error-tracking.ts` | Error tracking utilities |
| `apps/web/src/app/api/middleware/error-handler.ts` | API error handler |
| `packages/web/src/components/TestError.tsx` | Error testing component |

## Files to Modify

| File | Changes |
|------|---------|
| `apps/web/src/app/layout.tsx` | Wrap with ErrorBoundary |
| `next.config.js` | Add Sentry webpack plugin |
| `apps/web/.env.example` | Add GlitchTip variables |
| `package.json` | Add Sentry dependencies |

## Acceptance Criteria

- [ ] Sentry SDK installed and configured
- [ ] Client errors captured automatically
- [ ] Server errors captured automatically
- [ ] Error boundaries prevent app crashes
- [ ] Source maps uploaded to GlitchTip
- [ ] User context attached to errors
- [ ] Sensitive data properly sanitized
- [ ] Test errors appear in GlitchTip dashboard
- [ ] Performance impact minimal
- [ ] No errors in console from SDK

## Testing

```bash
# 1. Set up GlitchTip
cd deploy/analytics
docker-compose up -d

# 2. Access GlitchTip
open http://localhost:3002
# Create organization and project
# Get DSN from project settings

# 3. Configure environment
# Add DSN to .env.local

# 4. Start development server
pnpm dev

# 5. Test error capture
# Add TestError component to a page
# Click buttons to trigger different error types

# 6. Verify in GlitchTip dashboard
# Check Issues tab for captured errors
# Verify source maps are working (readable stack traces)

# 7. Test production build
pnpm build
pnpm start
# Repeat error tests
```

## Notes

- GlitchTip uses Sentry SDK for compatibility
- Source maps should only be uploaded in production
- Consider rate limiting in production
- User PII should be handled according to privacy policy
- Error sampling can reduce costs in high-traffic scenarios
- Regular cleanup of old issues recommended
- Consider setting up alerts for critical errors