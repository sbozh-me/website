# 0.9.4 - Monitoring Dashboard & Alerts

## Goal
Configure comprehensive monitoring dashboards in Umami and GlitchTip with custom reports, alert rules, and automated notifications for critical metrics and errors.

## Deliverables
- [ ] Configure Umami custom dashboards
- [ ] Set up GlitchTip alert rules
- [ ] Create custom metric reports
- [ ] Implement alert webhooks
- [ ] Build monitoring status page
- [ ] Configure automated reports
- [ ] Set up integration with dev workflow

## Implementation

### Umami Custom Dashboard Configuration

```javascript
// deploy/analytics/scripts/umami-setup.js
// Script to configure Umami dashboards via API

const UMAMI_API_URL = process.env.UMAMI_API_URL || 'http://localhost:3001/api';
const UMAMI_USERNAME = process.env.UMAMI_USERNAME || 'admin';
const UMAMI_PASSWORD = process.env.UMAMI_PASSWORD || 'umami';

class UmamiDashboard {
  constructor() {
    this.token = null;
  }

  async authenticate() {
    const response = await fetch(`${UMAMI_API_URL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        username: UMAMI_USERNAME,
        password: UMAMI_PASSWORD,
      }),
    });

    const data = await response.json();
    this.token = data.token;
    return this.token;
  }

  async createCustomReports() {
    const reports = [
      {
        name: 'Weekly Performance Report',
        type: 'performance',
        metrics: ['pageviews', 'sessions', 'bounce_rate', 'avg_time'],
        period: '7d',
        filters: {
          device: 'all',
          browser: 'all',
          country: 'all',
        },
      },
      {
        name: 'Conversion Funnel',
        type: 'funnel',
        steps: [
          { name: 'Landing Page', url: '/' },
          { name: 'Blog View', url: '/blog/*' },
          { name: 'Contact Form', url: '/contact' },
          { name: 'Form Submit', event: 'form_submit' },
        ],
      },
      {
        name: 'Error Tracking',
        type: 'events',
        events: ['error', 'api_error', 'performance_poor'],
        period: '24h',
      },
      {
        name: 'Content Performance',
        type: 'content',
        metrics: ['views', 'avg_time', 'exits'],
        content_type: 'blog',
        sort: 'views_desc',
      },
    ];

    for (const report of reports) {
      await this.createReport(report);
    }
  }

  async createReport(config) {
    const response = await fetch(`${UMAMI_API_URL}/reports`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`,
      },
      body: JSON.stringify(config),
    });

    return response.json();
  }

  async configureAlerts() {
    const alerts = [
      {
        name: 'High Bounce Rate Alert',
        metric: 'bounce_rate',
        threshold: 70,
        comparison: 'greater_than',
        period: '1h',
        webhook: process.env.ALERT_WEBHOOK_URL,
      },
      {
        name: 'Traffic Spike Alert',
        metric: 'pageviews',
        threshold: 1000,
        comparison: 'greater_than',
        period: '1h',
        webhook: process.env.ALERT_WEBHOOK_URL,
      },
      {
        name: 'Performance Degradation',
        metric: 'avg_load_time',
        threshold: 3000,
        comparison: 'greater_than',
        period: '30m',
        webhook: process.env.ALERT_WEBHOOK_URL,
      },
    ];

    for (const alert of alerts) {
      await this.createAlert(alert);
    }
  }

  async createAlert(config) {
    // Note: Umami doesn't have built-in alerts, this would need custom implementation
    console.log('Alert configuration:', config);
    // Store in database or external monitoring service
  }
}

// Run setup
async function setupUmamiDashboard() {
  const dashboard = new UmamiDashboard();
  await dashboard.authenticate();
  await dashboard.createCustomReports();
  await dashboard.configureAlerts();
  console.log('Umami dashboard configured successfully');
}

if (require.main === module) {
  setupUmamiDashboard().catch(console.error);
}

module.exports = { UmamiDashboard };
```

### GlitchTip Alert Configuration

```python
# deploy/analytics/scripts/glitchtip_setup.py
import os
import requests
from typing import Dict, List

GLITCHTIP_URL = os.getenv('GLITCHTIP_URL', 'http://localhost:3002')
GLITCHTIP_TOKEN = os.getenv('GLITCHTIP_AUTH_TOKEN')

class GlitchTipAlerts:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {GLITCHTIP_TOKEN}',
            'Content-Type': 'application/json'
        })

    def create_alert_rules(self, project_id: str):
        """Create comprehensive alert rules for different error types"""

        rules = [
            {
                'name': 'Critical Error Surge',
                'conditions': [
                    {
                        'id': 'sentry.rules.conditions.event_frequency.EventFrequencyCondition',
                        'value': 10,
                        'interval': '1h'
                    },
                    {
                        'id': 'sentry.rules.conditions.level.LevelCondition',
                        'level': 'error'
                    }
                ],
                'actions': [
                    {
                        'id': 'sentry.rules.actions.notify_event.NotifyEventAction',
                        'targetType': 'Team',
                        'targetIdentifier': 'engineering'
                    }
                ],
                'frequency': 30  # minutes
            },
            {
                'name': 'New Error Type',
                'conditions': [
                    {
                        'id': 'sentry.rules.conditions.first_seen_event.FirstSeenEventCondition'
                    }
                ],
                'actions': [
                    {
                        'id': 'sentry.integrations.slack.notify_action.SlackNotifyServiceAction',
                        'channel': '#alerts',
                        'workspace': 'sbozh'
                    }
                ],
                'frequency': 0  # immediate
            },
            {
                'name': 'Performance Regression',
                'conditions': [
                    {
                        'id': 'sentry.rules.conditions.event_attribute.EventAttributeCondition',
                        'attribute': 'transaction.duration',
                        'operator': 'gt',
                        'value': 5000  # 5 seconds
                    }
                ],
                'actions': [
                    {
                        'id': 'sentry.rules.actions.notify_event.NotifyEventAction',
                        'targetType': 'User',
                        'targetIdentifier': 'owner'
                    }
                ],
                'frequency': 60  # minutes
            },
            {
                'name': 'Error Rate Spike',
                'conditions': [
                    {
                        'id': 'sentry.rules.conditions.event_frequency.EventFrequencyPercentCondition',
                        'value': 100,  # 100% increase
                        'interval': '1h'
                    }
                ],
                'actions': [
                    {
                        'id': 'sentry.rules.actions.notify_event_service.NotifyEventServiceAction',
                        'service': 'webhook',
                        'url': os.getenv('ALERT_WEBHOOK_URL')
                    }
                ],
                'frequency': 30
            }
        ]

        for rule in rules:
            response = self.session.post(
                f'{GLITCHTIP_URL}/api/0/projects/{project_id}/rules/',
                json=rule
            )
            if response.status_code == 201:
                print(f"Created rule: {rule['name']}")
            else:
                print(f"Failed to create rule: {rule['name']} - {response.text}")

    def configure_integrations(self, organization_id: str):
        """Set up integrations for alerts"""

        integrations = [
            {
                'provider': 'slack',
                'name': 'Slack Alerts',
                'config': {
                    'webhook_url': os.getenv('SLACK_WEBHOOK_URL'),
                    'channel': '#monitoring'
                }
            },
            {
                'provider': 'email',
                'name': 'Email Alerts',
                'config': {
                    'email': 'alerts@sbozh.me',
                    'smtp_host': os.getenv('SMTP_HOST'),
                    'smtp_port': 587,
                    'smtp_username': os.getenv('SMTP_USERNAME'),
                    'smtp_password': os.getenv('SMTP_PASSWORD')
                }
            },
            {
                'provider': 'webhook',
                'name': 'Custom Webhook',
                'config': {
                    'url': os.getenv('CUSTOM_WEBHOOK_URL'),
                    'method': 'POST',
                    'headers': {
                        'Content-Type': 'application/json',
                        'X-API-Key': os.getenv('WEBHOOK_API_KEY')
                    }
                }
            }
        ]

        for integration in integrations:
            response = self.session.post(
                f'{GLITCHTIP_URL}/api/0/organizations/{organization_id}/integrations/',
                json=integration
            )
            if response.status_code == 201:
                print(f"Created integration: {integration['name']}")
            else:
                print(f"Failed to create integration: {integration['name']}")

if __name__ == '__main__':
    alerts = GlitchTipAlerts()
    alerts.create_alert_rules('website-project')
    alerts.configure_integrations('sbozh')
```

### Monitoring Status Page Component

```tsx
// packages/web/src/components/MonitoringStatus.tsx
'use client';

import { useEffect, useState } from 'react';
import { Alert, AlertDescription, AlertTitle } from '@sbozh/react-ui/components/ui/alert';
import { Badge } from '@sbozh/react-ui/components/ui/badge';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@sbozh/react-ui/components/ui/card';
import { Progress } from '@sbozh/react-ui/components/ui/progress';

interface ServiceStatus {
  name: string;
  status: 'operational' | 'degraded' | 'outage';
  uptime: number;
  responseTime: number;
  lastCheck: Date;
}

interface Metrics {
  pageViews: number;
  uniqueVisitors: number;
  avgLoadTime: number;
  errorRate: number;
  uptime: number;
}

export function MonitoringStatus() {
  const [services, setServices] = useState<ServiceStatus[]>([]);
  const [metrics, setMetrics] = useState<Metrics | null>(null);
  const [incidents, setIncidents] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchMonitoringData();
    const interval = setInterval(fetchMonitoringData, 60000); // Update every minute
    return () => clearInterval(interval);
  }, []);

  async function fetchMonitoringData() {
    try {
      // Fetch from your monitoring API
      const [servicesRes, metricsRes, incidentsRes] = await Promise.all([
        fetch('/api/monitoring/services'),
        fetch('/api/monitoring/metrics'),
        fetch('/api/monitoring/incidents'),
      ]);

      if (servicesRes.ok) {
        setServices(await servicesRes.json());
      }
      if (metricsRes.ok) {
        setMetrics(await metricsRes.json());
      }
      if (incidentsRes.ok) {
        setIncidents(await incidentsRes.json());
      }
    } catch (error) {
      console.error('Failed to fetch monitoring data:', error);
    } finally {
      setLoading(false);
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'operational':
        return 'bg-green-500';
      case 'degraded':
        return 'bg-yellow-500';
      case 'outage':
        return 'bg-red-500';
      default:
        return 'bg-gray-500';
    }
  };

  const getStatusBadgeVariant = (status: string): any => {
    switch (status) {
      case 'operational':
        return 'default';
      case 'degraded':
        return 'secondary';
      case 'outage':
        return 'destructive';
      default:
        return 'outline';
    }
  };

  if (loading) {
    return <div>Loading monitoring data...</div>;
  }

  const overallStatus = services.every(s => s.status === 'operational')
    ? 'operational'
    : services.some(s => s.status === 'outage')
    ? 'outage'
    : 'degraded';

  return (
    <div className="space-y-6">
      {/* Overall Status */}
      <Alert className={overallStatus === 'operational' ? 'border-green-500' : overallStatus === 'outage' ? 'border-red-500' : 'border-yellow-500'}>
        <AlertTitle>System Status</AlertTitle>
        <AlertDescription>
          <div className="flex items-center justify-between">
            <span>
              {overallStatus === 'operational' && 'All systems operational'}
              {overallStatus === 'degraded' && 'Experiencing degraded performance'}
              {overallStatus === 'outage' && 'Service disruption detected'}
            </span>
            <Badge variant={getStatusBadgeVariant(overallStatus)}>
              {overallStatus.toUpperCase()}
            </Badge>
          </div>
        </AlertDescription>
      </Alert>

      {/* Services Status */}
      <Card>
        <CardHeader>
          <CardTitle>Services</CardTitle>
          <CardDescription>Real-time service health monitoring</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {services.map((service) => (
              <div key={service.name} className="flex items-center justify-between p-3 border rounded">
                <div className="flex items-center gap-3">
                  <div className={`w-3 h-3 rounded-full ${getStatusColor(service.status)}`} />
                  <div>
                    <p className="font-medium">{service.name}</p>
                    <p className="text-sm text-muted-foreground">
                      Response: {service.responseTime}ms | Uptime: {service.uptime}%
                    </p>
                  </div>
                </div>
                <div className="text-right">
                  <Badge variant={getStatusBadgeVariant(service.status)}>
                    {service.status}
                  </Badge>
                  <p className="text-xs text-muted-foreground mt-1">
                    Last check: {new Date(service.lastCheck).toLocaleTimeString()}
                  </p>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Key Metrics */}
      {metrics && (
        <Card>
          <CardHeader>
            <CardTitle>Key Metrics (24h)</CardTitle>
            <CardDescription>Performance and usage statistics</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
              <div>
                <p className="text-sm font-medium">Page Views</p>
                <p className="text-2xl font-bold">{metrics.pageViews.toLocaleString()}</p>
              </div>
              <div>
                <p className="text-sm font-medium">Unique Visitors</p>
                <p className="text-2xl font-bold">{metrics.uniqueVisitors.toLocaleString()}</p>
              </div>
              <div>
                <p className="text-sm font-medium">Avg Load Time</p>
                <p className="text-2xl font-bold">{metrics.avgLoadTime}ms</p>
              </div>
              <div>
                <p className="text-sm font-medium">Error Rate</p>
                <p className="text-2xl font-bold">{metrics.errorRate}%</p>
              </div>
              <div>
                <p className="text-sm font-medium">Uptime</p>
                <div className="flex items-center gap-2">
                  <Progress value={metrics.uptime} className="flex-1" />
                  <span className="text-sm font-medium">{metrics.uptime}%</span>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Recent Incidents */}
      {incidents.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle>Recent Incidents</CardTitle>
            <CardDescription>Last 7 days</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {incidents.map((incident, index) => (
                <div key={index} className="p-3 border rounded">
                  <div className="flex items-center justify-between mb-2">
                    <Badge variant={incident.resolved ? 'outline' : 'destructive'}>
                      {incident.resolved ? 'Resolved' : 'Active'}
                    </Badge>
                    <span className="text-sm text-muted-foreground">
                      {new Date(incident.timestamp).toLocaleString()}
                    </span>
                  </div>
                  <p className="font-medium">{incident.title}</p>
                  <p className="text-sm text-muted-foreground">{incident.description}</p>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

### Monitoring API Endpoints

```typescript
// apps/web/src/app/api/monitoring/services/route.ts
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // Check service health
    const services = await Promise.all([
      checkService('Website', process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'),
      checkService('Analytics', process.env.UMAMI_URL || 'http://localhost:3001'),
      checkService('Error Tracking', process.env.GLITCHTIP_URL || 'http://localhost:3002'),
      checkService('CMS', 'http://localhost:8055'),
    ]);

    return NextResponse.json(services);
  } catch (error) {
    return NextResponse.json({ error: 'Failed to fetch services' }, { status: 500 });
  }
}

async function checkService(name: string, url: string): Promise<any> {
  const startTime = Date.now();

  try {
    const response = await fetch(url, {
      method: 'HEAD',
      signal: AbortSignal.timeout(5000),
    });

    const responseTime = Date.now() - startTime;

    return {
      name,
      status: response.ok ? 'operational' : 'degraded',
      uptime: 99.9, // Would be calculated from historical data
      responseTime,
      lastCheck: new Date(),
    };
  } catch (error) {
    return {
      name,
      status: 'outage',
      uptime: 0,
      responseTime: 0,
      lastCheck: new Date(),
    };
  }
}
```

### Automated Reporting

```typescript
// deploy/analytics/scripts/automated-reports.ts
import { CronJob } from 'cron';
import nodemailer from 'nodemailer';

interface Report {
  name: string;
  schedule: string;
  recipients: string[];
  generateReport: () => Promise<any>;
}

class AutomatedReports {
  private transporter: any;
  private reports: Report[] = [];

  constructor() {
    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: 587,
      secure: false,
      auth: {
        user: process.env.SMTP_USERNAME,
        pass: process.env.SMTP_PASSWORD,
      },
    });

    this.setupReports();
  }

  setupReports() {
    this.reports = [
      {
        name: 'Weekly Analytics Summary',
        schedule: '0 9 * * MON', // Every Monday at 9 AM
        recipients: ['team@sbozh.me'],
        generateReport: this.generateAnalyticsSummary,
      },
      {
        name: 'Daily Error Report',
        schedule: '0 10 * * *', // Every day at 10 AM
        recipients: ['dev@sbozh.me'],
        generateReport: this.generateErrorReport,
      },
      {
        name: 'Monthly Performance Report',
        schedule: '0 9 1 * *', // First day of month at 9 AM
        recipients: ['team@sbozh.me', 'stakeholders@sbozh.me'],
        generateReport: this.generatePerformanceReport,
      },
    ];

    // Schedule all reports
    this.reports.forEach(report => {
      new CronJob(report.schedule, async () => {
        await this.sendReport(report);
      }, null, true);

      console.log(`Scheduled report: ${report.name}`);
    });
  }

  async generateAnalyticsSummary() {
    // Fetch data from Umami API
    const data = await fetch(`${process.env.UMAMI_API_URL}/stats/summary?period=7d`);
    const summary = await data.json();

    return {
      subject: 'Weekly Analytics Summary',
      html: `
        <h2>Weekly Analytics Summary</h2>
        <ul>
          <li>Page Views: ${summary.pageviews}</li>
          <li>Unique Visitors: ${summary.uniques}</li>
          <li>Bounce Rate: ${summary.bounceRate}%</li>
          <li>Avg Session Duration: ${summary.avgDuration}s</li>
        </ul>
      `,
      attachments: [
        {
          filename: 'weekly-report.json',
          content: JSON.stringify(summary, null, 2),
        },
      ],
    };
  }

  async generateErrorReport() {
    // Fetch data from GlitchTip API
    const data = await fetch(`${process.env.GLITCHTIP_API_URL}/issues?period=24h`, {
      headers: {
        'Authorization': `Bearer ${process.env.GLITCHTIP_TOKEN}`,
      },
    });
    const issues = await data.json();

    return {
      subject: `Daily Error Report - ${issues.length} issues`,
      html: `
        <h2>Daily Error Report</h2>
        <p>Total Issues: ${issues.length}</p>
        <ul>
          ${issues.slice(0, 10).map((issue: any) => `
            <li>
              <strong>${issue.title}</strong><br>
              Count: ${issue.count} | Last seen: ${issue.lastSeen}
            </li>
          `).join('')}
        </ul>
      `,
    };
  }

  async generatePerformanceReport() {
    // Aggregate performance data
    return {
      subject: 'Monthly Performance Report',
      html: `
        <h2>Monthly Performance Report</h2>
        <p>Detailed performance metrics for the past month</p>
        <!-- Add charts, tables, etc. -->
      `,
    };
  }

  async sendReport(report: Report) {
    try {
      const content = await report.generateReport();

      await this.transporter.sendMail({
        from: '"Monitoring System" <monitoring@sbozh.me>',
        to: report.recipients.join(', '),
        ...content,
      });

      console.log(`Sent report: ${report.name}`);
    } catch (error) {
      console.error(`Failed to send report: ${report.name}`, error);
    }
  }
}

// Initialize automated reports
if (process.env.NODE_ENV === 'production') {
  new AutomatedReports();
}
```

## Files to Create

| File | Purpose |
|------|---------|
| `deploy/analytics/scripts/umami-setup.js` | Umami dashboard configuration |
| `deploy/analytics/scripts/glitchtip_setup.py` | GlitchTip alert rules |
| `packages/web/src/components/MonitoringStatus.tsx` | Status page component |
| `apps/web/src/app/api/monitoring/*/route.ts` | Monitoring API endpoints |
| `deploy/analytics/scripts/automated-reports.ts` | Automated reporting system |

## Files to Modify

| File | Changes |
|------|---------|
| `deploy/analytics/docker-compose.yml` | Add monitoring services |
| `deploy/analytics/.env.example` | Add alert webhook URLs |
| `package.json` | Add cron and nodemailer dependencies |

## Acceptance Criteria

- [ ] Umami dashboards configured with custom reports
- [ ] GlitchTip alert rules active
- [ ] Alert notifications working (email/webhook)
- [ ] Status page displays real-time data
- [ ] Automated reports sent on schedule
- [ ] Performance metrics tracked
- [ ] Error trends visible
- [ ] Integration with dev workflow
- [ ] Alert fatigue minimized
- [ ] Documentation complete

## Testing

```bash
# 1. Test Umami dashboard setup
cd deploy/analytics
node scripts/umami-setup.js

# 2. Test GlitchTip alerts
python scripts/glitchtip_setup.py

# 3. Test monitoring endpoints
curl http://localhost:3000/api/monitoring/services
curl http://localhost:3000/api/monitoring/metrics

# 4. Test alert webhooks
# Trigger test alerts from GlitchTip dashboard

# 5. Test automated reports
# Manually trigger report generation
node -e "require('./scripts/automated-reports').generateAnalyticsSummary()"

# 6. Load test to trigger alerts
artillery quick --count 100 --num 10 http://localhost:3000
```

## Notes

- Configure alert thresholds based on baseline metrics
- Use webhook integrations for Slack/Discord notifications
- Consider implementing SLAs and SLOs
- Regular review of alert rules to prevent fatigue
- Archive old reports for historical analysis
- Consider using Grafana for advanced visualizations in future